%===============================================================================
%===============================================================================
%
% This function runs the optimization problem that fits the forward SMIM model
% to data.
%
% NOTE: Currently, the optimization function is hard-coded to be lsqnonlin(),
%       but this could be generalized, if desired.
%
%===============================================================================
%
% Inputs:
%   mymeas       := measurement (conservative or reactive)
%   obj_function := function handle for the objective function to be minimized
%   data         := struct provided to the objective function--objFunctionSMIM()
%                   for further information
%   pdf_function := function handle for the pdf function that is provided to the
%                   objective function--this is the SMIM forward model, and is
%                   set in SMIMfit()
%   params_guess := initial guess for parameters to be fitted by the optimization function
%   params_upper := upper bound for the parameters to be fitted
%   params_lower := lower bound for the parameters to be fitted
%   varargin     := optional input (only when called during the reactive
%                   fit), holding:
%       - transParams := transport parameters generated by the conservative fit
%
% Outputs:
%   M := struct containing the results of the fit--see SMIMfit() for details
%
%===============================================================================
%===============================================================================

function M = runFit(mymeas, obj_function, data, pdf_function,...
                    params_guess, params_upper, params_lower, varargin)

%Parameters for optimization
    maxiter = 10000; %Maximum number of iterations
    restart = 60; %Number of random restarts
    tol = 1e-14; %Tolerance

%Define the optimization problem    
    f = @(fitParams) obj_function(fitParams, 1, data, pdf_function);

    opts = optimoptions(@lsqnonlin, 'FunctionTolerance', tol, 'FiniteDifferenceType', 'central', 'MaxFunctionEvaluations', maxiter,...
        'OptimalityTolerance', tol, 'StepTolerance', tol, 'MaxIterations', maxiter, 'Display', 'iter');

    problem = createOptimProblem('lsqnonlin','objective',...
        f,'x0',params_guess,'lb',params_lower,'ub',params_upper,'options',opts);

%Select random start points    
    points = lhsdesignbnd(restart,6,params_lower, params_upper);
    points(restart + 1,:) = params_guess;
    starts = CustomStartPointSet(points);

%Incorporate random restarts into the optimization
    ms = MultiStart('FunctionTolerance',tol,'XTolerance',tol);
    x0 = run(ms,problem,starts);

%Put the best solution into one additional run to extract the jacobian,
%which is needed to calculate the standard error
    [x,resnorm,residual,exitflag,output,lambda,jacobian] = lsqnonlin(f, x0, params_lower, params_upper, opts); 

% Write out the results to the results struct
    M.params_fit = x;
    M.resnorm = resnorm;
    M.resid = residual;
    M.jacobian = jacobian;
    M.lambda = lambda;


%The below lines relate to the reactive fit, which we plan to eventually incorporate into the code. This does not do much for now. 

        % write the fitted concentration curve to the results struct
        %     NOTE: not sure if the 'ccfit' vs. 'crfit' convention is strictly
        %     necessary, but decided to keep it as is
        switch mymeas
            case 'c'
                M.ccfit = pdf_function([M.params_fit], data);
            case 'r'
                M.crfit = pdf_function([M.params_fit], data);
        end


end
